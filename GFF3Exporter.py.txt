#!usr/bin/env python3

'''
Write a GFF3 feature exporter

Run Format:

$export_gff3_feature_.py --source_gff=/path/to/some.gff --type=gene --attribute=ID --value=YAR003W


will look like this with STDOUT print

>gene:ID:YAR003W
..sequence

#read the path GFF3 file
#find the gene(column3)
#ID at column 9
# use columns 4 and 5 and 7 (4 = start , 5 = end)
#with fasta at end of document
'''
#Methods
#1.collect source, type , attribute,value based on parser argument
#2. use regex to look for fasta code [ACTG]* count and assign to ID value
import argparse
import re


def main():
        parser = argparse.ArgumentParser( description = 'Take in user arguments for GFF3 ')

        ## output file to be written
        parser.add_argument( '-i' , '--input_file' , type =str, required =True, help = 'Path to an input file to be read')
        parser.add_argument( '--type' , '--type' , type =str, required =True, help = 'Type to be read')
        parser.add_argument( '--attribute' , '--attribute' , type =str, required =True, help = 'Attribute to be read')
        parser.add_argument( '--value' , '--value' , type =str, required =True, help = 'value to be read')

        args = parser.parse_args()
        f= open(args.input_file)

        #assign user arguments into variables
        in_type = args.type
        in_id = args.attribute
        in_value = args.value

        #preset variables to take from line
        type_of_seq =""
        id_type=""
        id_value=""
        appnd_data=""
        start =""
        end =""
        strand_type=""

        for line in f:
                #for each line, split into the neccessary categories i.e. ID, type ,attribute
                #none of it is saved
                line = line.rstrip()
                #split based on tabs
		cols = line.split("\t")


                if len(cols)!= 9:
                        continue


                if cols[2] == in_type:
                        type_of_seq = cols[2]


                #ID and name at column 9 (8); to separate split based on ID = and Name =
                attributes = cols[8]
                attributes = attributes.split(';')
                ID = attributes[0]
                ID = ID.split('=')

                if ID[0] == in_id:
                        id_type =ID[0]
                if ID[1] == in_value:
                        id_value = ID[1]

                if type_of_seq == in_type and id_type == in_id and id_value == in_value:
                        #This is use to match with FASTA files
                        chrom_type =cols[0]
                        start = cols[3]
                        end = cols[4]
                        strand_type = cols[6]
                        break



                #replace gene/value/id with parser arguments                                                                     
	if type_of_seq == in_type and id_type == in_id and id_value == in_value:
                appnd_data = ">" + type_of_seq + ":" + id_type + ":" + id_value
                print(appnd_data)
                print("...sequence here...")
                #155005 156285 +
                fasta(f,chrom_type,start,end,strand_type)
        else:
                print("No query match")


#match the fasta sequence to the entry (with 1,4,5,7)
def fasta(f,chrom_type,start,end,strand_type):
        headline = ">" + chrom_type
        full_seq =""
 	sequence =""
        for line in f:
                m =re.match(r'[ATCG]+$' , line)
                if line.strip() ==headline:
                        continue
                if m:
                        full_seq += line
                if line.startswith('>') and not headline:
                        break
        x=int(start)
        y=int(end)
        difference = (y-x)+1
        for x in range(difference):
                sequence +=full_seq[x]


        #if strand is + print it as it is, if - put it in the complement formula
        if strand_type == '+' or strand_type =='.' or strand_type =='?':
                print(sequence)
        elif strand_type =='-':
                print(rev_complement(sequence))

# reverse complement method taken from Q4
#having a little trouble getting the complement method to work
#None to string type error
def rev_complement(sequence):
        complement ={'A' : 'T' , 'T' : 'A' , 'G' : 'C', 'C':'G'}
        rev_comp = ""
        for nt in sequence:
                if complement.get(nt) is not None:
                        rev_comp += complement.get(nt)
        return rev_comp



if __name__ =='__main__':
        main()
